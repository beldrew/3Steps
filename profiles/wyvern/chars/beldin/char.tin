#class {beldin} {kill}
#class {beldin} {open}

#var guild sii

#ticker {gxp}{#send {}}{240};

#send {!gset hpbar HP:$HP$ SP:$SP$ FO:$FORT$ CON:$CON$/$CONMAX$ EN:$FOE$ P:$PERC$ MIT:$MIT$ $NL$CH:$CHO$ GL:$CL$ GXP:$GXP$ FI:$FI$ Brood:$BROOD$ B:$BST$ M:$MAS$ $NL$OL:$OVER$ BR:$BR$ AMP:$AMP$ RT:$RT$ SH:$PS$ CL:$PC$ PG:$PG$ R:$REG$};

#alias info siihelp %0
#alias rcost siiscore stat cost
#alias gskills siiscore skills
#alias gs2 siiscore skills
#alias gs3 siiscore forms
#alias gs4 siiscore history
#alias gs5 siiscore mastery
#alias pstats siiscore combat
#act {You step out of the cubicle and adjust to your new senses.}{doshield;!psipulse}

#var my[desired][shield] {adapt};
#alias swapshield {
	#if {"${my[desired][shield]}" == "reflect"}{
			#var my[desired][shield] {absorb};
			#echo {Absorb};
	};
	#if {"${my[desired][shield]}" == "augment"}{
			#var my[desired][shield] {reflect};
			#echo {Reflect};
	};
	#if {"${my[desired][shield]}" == "adapt"}{
			#var my[desired][shield] {augment};
			#echo {Augment};
	};
	#if {"${my[desired][shield]}" == "protect abrasive"}{
			#var my[desired][shield] {adapt};
			#echo {Adapt};
	};
	#if {"${my[desired][shield]}" == "protect impact"}{
			#var my[desired][shield] {protect abrasive};
			#echo {Protect Abrasive};
	};
	#if {"${my[desired][shield]}" == "absorb"}{
			#var my[desired][shield] {protect impact};
			#echo {Protect Impact};
	};
	#echo {doshield to activate your new shield};
};

#alias {doshield}{
	!shield off;
	!boost;
	!shield ${my[desired][shield]};
	#echo;
	#echo {swapshield to switch};
};




#act {HP:%1/%2 SP:%3/%4 FO:%5/%6 CON:%7/%8 EN:%9 P:%10 MIT:%11}{
	#var {my[hp][current]}		{%1};
	#var {my[hp][max]}			{%2};
	#var {sii[maxHp]} 			{%2};
	#var {my[sp][current]}		{%3};
	#var {my[sp][max]}			{%4};
	#var {my[gp1][current]}		{%5};
	#var {my[fort][current]}	{%5};
	#var {my[gp1][max]}			{%6};
	#var {my[fort][max]}		{%6};

	#var {my[control][current][integer]}{%7};
	#var {my[control][max][integer]}{%8};

	#var {my[enemy]}		{%9};

	#if {"$my[enemy]" == "None"}{#var my[incombat] 0}{#var my[incombat] 1};
	#if {$my[incombat] == 1}{
		#math {my[damagetracker][rounds]}{$my[damagetracker][rounds] + 1};
            #regex {$my[enemy]}{%*(%*)}{
                #var {my[damagetracker][foe]}{&1};
            };
	};
	#var {my[perception][current]}		{%10};
	#var {my[mitigation][current]}		{%11};
}

#act {CH:%1 GL:%2 GXP:%3 FI: Brood:%5 B:%6 (%7) M:%8}{
	#var my[choose][current] %1;
	#var my[gtnl][current][integer] %2;
	#var my[gxp][round][integer] %3;
	#var my[form][current] None;
	#var my[brood][current] %5;
	#var my[boost][current] %6;
	#var my[boost][status] %7;
}

#var my[control][level] 12;
#math my[brood][max] {$my[control][level] * 2};
#var my[ktrig] k1;

#act {CH:%1 GL:%2 GXP:%3 FI:%4 Brood:%5 B:%6 (%7)}{
	#var my[choose][current] %1;
	#var my[gtnl][current][integer] %2;
	#var my[gxp][round][integer] %3;
	#var my[form][current] %4;
	#var my[brood][current] %5;
	#var my[boost][current] %6;
	#var my[boost][status] %7;

	#NOP #IF {$my[brood][current] >= $my[brood][max] && "$my[ktrig]" != "k1"}
	#NOP {
	#NOP 	#send {k1};
	#NOP 	#var my[ktrig] k1;
	#NOP };
	#NOP #ELSEIF {$my[brood][current] < $my[brood][max]  && "$my[ktrig]" != "k4"}
	#NOP {
	#NOP 	#send {k4};
	#NOP 	#var my[ktrig] k4;
	#NOP };
};

#act {OL:%1 (%2) BR:%3 AMP:%4 RT:%5 SH:%6 CL:%7 PG:%8 R:%9}{
	#var my[overload][current] %1;
	#var my[overload][status] %2;
	#var my[bloodrush][current] %3;
	#var my[amplify][current] %4;
	#var my[root][current] %5;
	#var my[psishield][current] %6;
	#var my[cleanse][current] %7;
	#var my[psighost][current] %8;
	#var my[regeneration][current] %9;

	update_status;
	#line gag;
}

#alias {update_status} {
	#var	{my[hp][graph]}		{@graph{$my[hp][current];$my[hp][max]}};
	#var	{my[sp][graph]}		{@graph{$my[sp][current];$my[sp][max]}};
	#var	{my[gp1][graph]}	{@graph{$my[gp1][current];$my[gp1][max]}};
	#var	{my[control][graph]}	{@graph{$my[control][current][integer];$my[control][max][integer]}};
	#var	{enemy[graph]}		{@graph{$enemy[hp];100}};
	#format {hp}			{%+4s} {@colscale{$my[hp][current];$my[hp][max]}};
	#format {hp_max}		{%+4s} {<128>$my[hp][max]<088>};
	#format {sp}			{%+4s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_max}		{%+4s} {<128>$my[sp][max]<088>};
	#format {fo}			{%+4s} {@colscale{$my[gp1][current];$my[gp1][max]}};
	#format {fo_max}		{%+4s} {<128>$my[gp1][max]<088>};
	#format {co}			{%+4s} {@colscale{$my[control][current][integer];$my[control][max][integer]}};
	#format {co_max}		{%+4s} {<128>$my[control][max][integer]<088>};
	#format {ehealth}		{%+6s} {@colscale{$enemy[hp];100}\%};
	#if {"$draw[hpbar]" == "on"} {
		#showme {<088>HP:${hp}/${hp_max} SP:${sp}/${sp_max} FO:${fo}/${fo_max} CO:${co}/${co_max} E: ${ehealth}} {-4};
		#showme {H:${my[hp][graph]} S:${my[sp][graph]} F:${my[gp1][graph]} C:${my[control][graph]} E:${enemy[graph]}} {-3};
	};
	#if {"$draw[gline]" == "on"} {
		#if {"$draw[hpbar]" == "on"} {
			#showme { $mip[gline][1]}{-7};
			#showme { $mip[gline][2]}{-6};
		}{
			#showme { $mip[gline][1]}{-4};
			#showme { $mip[gline][2]}{-3};
		}
	};
};

#action {%*There is no usable corpse here for you to envelop}{#send {!brood feed};};

#action {%*You attempt to infest the corpse, but the remaining residual energy}{#send {!brood feed};};

#gag {Your neural overload capability is already off.};

#gag {Your metabolism is already regenerating at a %w rate.};

#alias {resethp}
{
	#send {!hp};
	#delay {3}
	{
		#math sii[regenHp] {$sii[maxHp] * 0.7};
		#format sii[regenHp] {%d} {$sii[regenHp]};

		#math sii[normalHp] {$sii[maxHp] * 0.95};
		#format sii[normalHp] {%d} {$sii[normalHp]};

		#math sii[overloadHp] {$sii[maxHp] * 0.5};
		#format sii[overloadHp] {%d} {$sii[overloadHp]};

		#send {!alias sii_reaction ifitem quietly/myhp<$sii[overloadHp]/overload on/myhp<$sii[regenHp]/focus regen burning/myhp>$sii[normalHp]/focus regen normal/-};

	};
};

#alias oextra {ta};
#alias o {envelop};

#action {%* dealt the killing blow to}{
	#send {!get coins from corpse};
	#send {!get coins};
	oextra;
};

#action {%*The corpse explodes as a small vicious lizard-like creature bursts forth}{#showme {There is no reason to 'inch' here.};};
#action {%*As the corpse explodes, %* small vicious lizard-like creature bursts forth}{#showme {There is no reason to 'inch' here.};};
#action {%*You cannot find a corpse to feed your brood}{#showme {There is no reason to 'inch' here.};};
#action {%*You have no way of sampling anything at the moment.}{#showme {There is no reason to 'inch' here.};};
#alias {next %*} {
	#action {There is no reason to 'inch' here.$}
	{
		#math sii[nextDelay] {1 d 6};
		#echo {Next delay: [$sii[nextDelay]] Action [%1]};
		#delay {$sii[nextDelay]}{
			%1;
		};
	};
};
next #bell;

#class {beldin} {close}
